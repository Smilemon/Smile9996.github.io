﻿---
layout:     post   				    # 使用的布局（不需要改）
title:      Redis《狂神》笔记 				# 标题 
subtitle:   #副标题
date:       2023-03-28				# 时间
author:     Smile 						# 作者
# header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Redis
---

<iframe allow="autoplay *; encrypted-media *;" frameborder="0" height="150" style="width:100%;max-width:660px;overflow:hidden;background:transparent;" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-storage-access-by-user-activation allow-top-navigation-by-user-activation" src="https://embed.music.apple.com/cn/album/%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81/1443352354?i=1443352467"></iframe>

# 一、Nosql
## 1、为什么使用Nosql

大数据时代！！普通的数据库无法进行数据分析！Hadoop(2006)。

 历史发展：

>1 、单机MySQL时代（90年代）,一个网站的访问量一般不会太大，单个数据库完全够用

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401151757496.png)

问题：
- 数据量增加到一定程度，单机数据库就放不下了
 - 数据的索引（B+ Tree）,一个机器内存也存放不下
 - 访问量变大后（读写混合），一台服务器承受不住。


> 2、MySQL+MemCache（缓存）+垂直拆分（读写分离）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401151826143.png)
将当个数据库扩展成为多个“垂直”的数据库，同时满足读写分离和数据一致性。
但是当访问量过大时频繁去数据库查询速度和效率低下。
这个优化过程经历了以下几个过程：

- 优化数据库的数据结构和索引(难度大)
- 文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了
- MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。

> 3、分库分表、主从复制=>集群

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401154217408.png)


> 4、如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。

数据库发展中：本质是对数据库的读和写。
早些年：MySIAM：表锁，效率问题低下，高并发下会有严重的锁问题。
转战innodb,行锁。
后来开始使用分库分表来解决写能力。

## 2、什么是Nosql

Nosql = Not Only SQL
不仅仅是数据库，泛指非关系型数据库。

关系型数据库：列+行，同一个表下数据的结构是一样的。
非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。（用户个人信息、社交网络、地理位置，这些数据不需要固定格式，使用map<key,value>键值对来控制）

## 3、Nosql特点
解耦！
 - 数据之间没有关系，方便扩展
 - 大数据量下，性能高。（一秒写入8W次 读取11W次）
 - 数据类型是多样性（不需要事先设计数据库，感受一下Mysql设计表和库的痛苦）

**传统 RDBMS 和 NoSQL**

> 传统的 RDBMS 
> - 结构化组织 - SQL
>  - 数据和关系都存在单独的表中 row col 
>  - 数据操作，数据定义语言 
>  - 严格的一致性
>   - 基础的事务 
>   - .....
> 
> Nosql
>  - 不仅仅是数据
>   - 没有固定的查询语言
>    - 键值对存储，列存储，文档存储，图形数据库（社交关系）
>         - 最终一致性，
>      - CAP定理和BASE （异地多活）
>      - 高性能，高可用，高可扩
>       - ....

**了解：3V+3高**

> 大数据时代的3V：主要是描述问题的
> 1. 海量Volume
> 2. 多样Variety
> 3. 实时Velocity
>   
> ---
> 
> 大数据时代的3高：主要是对程序的要求
> 1. 高并发
> 2. 高可扩
> 3. 高性能


真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的，阿里巴巴的架构演进！

## 4、阿里巴巴演进分析
思考问题：淘宝网站数据，这么多东西难道都是在一个数据库中的吗?
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021040116485438.png)
如果你未来相当一个架构师： 没有什么是加一层解决不了的！

> 1、商品的基本信息
>  - 名称、价格、商家信息；
>   -  关系型数据库就可以解决了！ MySQL / Oracle 
>   -  淘宝内部的 MySQL 不是大家用的 MySQL
> ---
> 2、商品的描述、评论（文字比较多
>   - 文档型数据库中，MongoDB
> ---
>   3、图片
>   分布式文件系统 FastDFS
>    - 淘宝自己的 TFS
>         - Gooale的 GFS
>      - Hadoop HDFS
>       - 阿里云的 oss
>---
>4、商品的关键字 （搜索）
> - 搜索引擎 solr elasticsearch
>  - ISerach：多隆（多去了解一下这些技术大佬！）
> ---
> 5、商品热门的波段信息
> - 内存数据库
>  - Redis Tair、Memache...
> ---
>  6、商品的交易，外部的支付接口
>  - 三方应用


大型互联网应用问题：
- 数据类型太多了！
- 数据源繁多，经常重构！
- 数据要改造，大面积改造？

解决问题：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401165648206.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401165706228.png)
## 5、NoSQL的四大分类
**KV键值对**

 - sina：Redis
 - 美团：Redis+Tair
 - alibaba、baidu：Redis+Memcache

**文档型数据库（bson格式 和json一样）**

 - MongoDB(掌握)

 	>MongoDB 是一个基于分布式文件存储的数据库，C++ 编写，主要用来处理大量的文档！
MongoDB 是一个介于关系型数据库和非关系型数据中中间的产品！MongoDB 是非关系型数
据库中功能最丰富，最像关系型数据库的！
 - ConthDB

**列存储数据库**

 - HBase
 - 分布式文件系统

**图关系数据库**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401170138599.png)
他不是存图形，放的是关系，比如：朋友圈社交网络，广告推荐！
Neo4j，InfoGrid；


**四者对比：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401170506842.png)

# 二、Redis入门
## 1、概述，Redis 是什么？

**Redis（Remote Dictionary Server )，即远程字典服务 !**
是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401170757932.png)
与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。

免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为结构化数据库！

## 2、Redis能干什么？
- 内存存储，需要持久化（RDB、AOF）
- 高效率、用于高速缓冲
- 发布订阅系统
- 地图信息分析
- 计时器、计数器(eg：浏览量)
- …

## 3、特性
- 多样的数据类型
- 持久化
- 集群
- 事务

## 4、Redis网站
官网：https://redis.io/
中文网：http://www.redis.cn/
下载地址：通过官网下载即可！

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021040117192213.png)


Redis推荐都是在Linux服务器上搭建的，我们是基于Linux学习！

## 5、环境搭建
### 5.1 window搭建
1、下载安装包：https://github.com/tporadowski/redis/releases
	![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401173839123.png)

2、下载完毕得到压缩包：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401174058215.png)

3、解压到自己电脑上的环境目录下的就可以的！
4、开启Redis，双击运行服务即可！
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401174153382.png)
5、连接测试：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401174417459.png)


### 5.2 Linux安装

1、下载安装包！`redis-6.2.1.tar.gz`
在官网上，点击下面链接下载。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210405184919220.png)
2、解压Redis的安装包！`tar -zxvf redis-6.2.1.tar.gz`

 程序文件一般放在：/opt 目录下 

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210408083743600.png)
3、进入解压后的文件，可以看到我们redis的配置文件

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210408083838700.png)
<font color = gree>**Redis的重要配置文件：redis.conf**

4、基本的环境安装

```bash
yum install gcc-c++   （基本命令的环境安装，c++写的）
make   （把所有命令安装上，安装环境，第一次安装比较慢）
make install	（确认命令的安装）
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/4f9e2a427af04882a49fdb006aecf190.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/f004cedcf4e3447ba469790bb459b542.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/62fa26e016924c188ee4a6b13c563f36.png)


5、redis的默认安装路径 `/usr/local/bin`
![在这里插入图片描述](https://img-blog.csdnimg.cn/36c1270d0b0a458b8f41d15f5d710ef9.png)

 6、将redis配置文件。复制到我们当前目录下

![在这里插入图片描述](https://img-blog.csdnimg.cn/857c7291c5524cb3af1117d8cd730593.png)

7、redis默认不是后台启动的，修改配置文件（改为yes，变成后台启动）
![在这里插入图片描述](https://img-blog.csdnimg.cn/efbb3c59df3c40b6af38fdad3ce23e92.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/b4c369bb347e428ba9f2b4c3a8856aa4.png)


8、启动Redis服务！

```bash
[root@MyCentOS8 bin]# redis-server rconfig/redis.conf 
```

9、使用redis-cli 进行连接测试！

![在这里插入图片描述](https://img-blog.csdnimg.cn/c79318b30ec84027bced4445fe554d23.png)

10、查看redis的进程是否开启！
![在这里插入图片描述](https://img-blog.csdnimg.cn/efc0fa1f1e1e4612b3fa7ce583037da3.png)

11、如何关闭Redis服务呢？ `shutdown`
![在这里插入图片描述](https://img-blog.csdnimg.cn/a255980e0bbf4531bd850e4a49f11068.png)


12、再次查看进程是否存在
![在这里插入图片描述](https://img-blog.csdnimg.cn/98a479e4dc3a40d080ef263cd8940986.png)

13、后面我们会使用单机多Redis启动集群测试！

### 5.3 测试性能
`redis-benchmark` 是一个压力测试工具！

官方自带的性能测试工具！
redis-benchmark 命令参数！

[菜鸟教程-Redis 性能测试](https://www.runoob.com/redis/redis-benchmarks.html)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420111619713.png?)

测试如下：

```bash
# 测试：100个并发连接 100000请求 
redis-benchmark -h localhost -p 6379 -c 100 -n 100000
```
截取了以下一部分：
![在这里插入图片描述](https://img-blog.csdnimg.cn/0642ade5138b42219d774a7a4c2dd792.png)

如何查看这些分析呢？
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420112111789.png)
### 5.4 基础的知识(基本命令)
redis默认有16个数据库(默认使用的是第0个)
![在这里插入图片描述](https://img-blog.csdnimg.cn/9f2ff28656314455b12eda112eba954e.png)
可以使用 select 进行切换数据库！`select` 
```bash
[root@MyCentOS8 bin]# redis-cli -p 6379
127.0.0.1:6379> select 3 #切换数据库
OK
127.0.0.1:6379[3]> DBSIZE #查看DB大小！
(integer) 0
127.0.0.1:6379[3]> set name xiaor1
OK
127.0.0.1:6379[3]> DBSIZE
(integer) 1
127.0.0.1:6379[3]> SELECT 7
OK
127.0.0.1:6379[7]> DBSIZE
(integer) 0
127.0.0.1:6379[7]> get name
(nil)
127.0.0.1:6379[7]> SELECT 3
OK
127.0.0.1:6379[3]> get name
"xiaor1"
```

查看当前数据库所有key `KEYS` 
```bash
127.0.0.1:6379[3]> KEYS * # 查看数据库所有的key
1) "name"

```
清除当前数据库 `FLUSHDB`

```bash
127.0.0.1:6379[3]> FLUSHDB
OK
127.0.0.1:6379[3]> KEYS *
(empty array)
```

清除全部数据库的内容 `FLUSHALL`

```bash
127.0.0.1:6379[3]> set name 123
OK
127.0.0.1:6379[3]> set age 23
OK
127.0.0.1:6379[3]> KEYS *
1) "name"
2) "age"
127.0.0.1:6379[3]> FLUSHALL
OK
127.0.0.1:6379[3]> KEYS *
(empty array)
127.0.0.1:6379[3]> SELECT 0
OK
127.0.0.1:6379> KEYS *
(empty array)

```

思考：为什么redis是 6379！粉丝效应！（了解一下即可！）

<font color = red>**Redis 是单线程的！**

明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！所有就使用了单线程了！

Redis 是C 语言写的，官方提供的数据为 100000+ 的QPS，完全不比同样是使用 key-vale的Memecache差！

**Redis 为什么单线程还这么快？**

1、误区1：高性能的服务器一定是多线程的？

2、误区2：多线程（CPU上下文会切换！）一定比单线程效率高！

速度：CPU>内存>硬盘

核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！

# 三、五大数据类型
官网：支持的数据类型
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420133632858.png)
全段翻译：

Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，<font color= red>它可以用作数据库、缓存和消息中间件MQ。</font> 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。

## 1、 Redis-Key
### 1.1 基本使用命令（常用）
```bash
127.0.0.1:6379> KEYS *   # 查看所有的key
(empty array)
127.0.0.1:6379> set name xiaor999  # set key
OK
127.0.0.1:6379> set age 30
OK
127.0.0.1:6379> KEYS *
1) "name"
2) "age"
127.0.0.1:6379> EXISTS name  # 判断当前的key是否存在
(integer) 1
127.0.0.1:6379> EXISTS name123
(integer) 0
127.0.0.1:6379> EXPIRE name 10 # 设置key的过期时间，单位是秒
(integer) 1
127.0.0.1:6379> ttl name # 查看当前key的剩余时间
(integer) 6
127.0.0.1:6379> ttl name
(integer) 3
127.0.0.1:6379> ttl name
(integer) -2
127.0.0.1:6379> get name
(nil)
127.0.0.1:6379> KEYS *
1) "age"
127.0.0.1:6379> type age # 查看当前key的一个类型！
string
127.0.0.1:6379> MOVE age 1  # 移除当前的key
(integer) 1
127.0.0.1:6379> KEYS * 
(empty array)
```

后面如果遇到不会的命令，可以在官网查看帮助文档！

中文网的命令：http://www.redis.cn/

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420135356720.png)
<font color = red>**Redis不区分大小命令**

## 2、String（字符串）

### 2.1 插入，获取，查看
**语法：**

设置（插入）值：`SET KEY(键) VALUE(值)`
获取值：`GET KEY(键)`
查看值是否存在：`EXISTS KEY(键)`
查看所有的键和值：`KEYS *`
拼接字符串：`APPEND KEY(键) VALUE(值)`
获取字符段长度：`STRLEN KEY(键)`

**举例：**
```bash
127.0.0.1:6379> SET key1 val1   # 设置值
OK
127.0.0.1:6379> get key1    # 获得值
"val1"
127.0.0.1:6379> EXISTS key1     # 判断某一个key是否存在
(integer) 1
127.0.0.1:6379> KEYS *   # 获得所有的key
1) "key1"
127.0.0.1:6379> APPEND key1 hello  # 追加字符串，如果当前key不存在，就相当于setkey (integer) 7
(integer) 9
127.0.0.1:6379> get key1
"val1hello"
127.0.0.1:6379> STRLEN key1  # 获取字符串的长度！
(integer) 9
127.0.0.1:6379> APPEND key1 world
(integer) 14
127.0.0.1:6379> STRLEN key1
(integer) 14
127.0.0.1:6379> get key1
"val1helloworld"
```

### 2.2 自增 自减

**语法：**

自增1：`INCR KEY`
自减1：`DECR KEY`
按步长增加：`INCRBY KEY INCREMENT`
按步长减少：`DECRBY KEY INCREMENT`

**举例：**
```bash
127.0.0.1:6379> set num 0  # 设置初始浏览量为0
OK
127.0.0.1:6379> get num
"0"
127.0.0.1:6379> INCR num  # 自增1  浏览量加1
(integer) 1
127.0.0.1:6379> INCR num
(integer) 2
127.0.0.1:6379> get num
"2"
127.0.0.1:6379> DECR num  # 自减1  浏览量减1
(integer) 1
127.0.0.1:6379> DECR num
(integer) 0
127.0.0.1:6379> DECR num
(integer) -1
127.0.0.1:6379> GET num
"-1"
127.0.0.1:6379> INCRBY num 10  # 设置自增步长，指定增量！
(integer) 9
127.0.0.1:6379> INCRBY num 11
(integer) 20
127.0.0.1:6379> DECRBY num 5   # 设置自减步长，指定减量！
(integer) 15
127.0.0.1:6379> GET num
"15"
```

### 2.3 字符串范围
**语法：**

获取指定范围的字符串：`GETRANGE KEY START END`

**举例：**
```bash
127.0.0.1:6379> set mykey "xiaor,hellojava"
OK
127.0.0.1:6379> get mykey
"xiaor,hellojava"
127.0.0.1:6379> GETRANGE mykey 0 3  # 截取字符串,第一个字符是从0开始
"xiao"
127.0.0.1:6379> GETRANGE mykey 0 -1   # 获取全部的字符串 和get key是一样的
"xiaor,hellojava"
```

### 2.4 替换
**语法：**

替换指定位置开始的字符串：`SETRANGE KEY OFFSET VALUE`

**举例：**

```bash
127.0.0.1:6379> set xiaokey asdfghjkl
OK
127.0.0.1:6379> get xiaokey
"asdfghjkl"
127.0.0.1:6379> SETRANGE xiaokey 2 hello  # 替换指定位置开始的字符串！
(integer) 9
127.0.0.1:6379> get xiaokey
"ashellokl"
```

### 2.5 设置过期时间
**语法：**

设置过期时间： `SETEX KEY SECONDS VALUE`
是否存在，再创建（如果不存在，再设置 （在分布式锁中会常常使用！） ）：`SETNX KEY VALUE`


**举例：**

```bash
127.0.0.1:6379> keys *
1) "num"
2) "xiaokey"
3) "key1"
4) "mykey"
127.0.0.1:6379> SETEX rrkey 30 "redis,java"  # 设置key的值,30秒后过期
OK
127.0.0.1:6379> ttl rrkey
(integer) 20
127.0.0.1:6379> get rrkey
"redis,java"
127.0.0.1:6379> ttl rrkey
(integer) 4
127.0.0.1:6379> ttl rrkey
(integer) -2
127.0.0.1:6379> SETNX bbkey "php,cc"   # 如果key不存在，创建key
(integer) 1
127.0.0.1:6379> keys *   # rrkey过期了，所以不显示
1) "num"
2) "bbkey"
3) "key1"
4) "xiaokey"
5) "mykey"
127.0.0.1:6379> SETNX bbkey "html,vue"   # 如果key存在，创建失败！
(integer) 0
127.0.0.1:6379> get bbkey
"php,cc"
```


### 2.6 同时插入和获取多个值
**语法:**

同时设置多个值：`MSET KEY VALUE [KEY VLAUE......]`
同时获取多个值：`MGET KEY [KEY......]`


**举例:**
```bash
127.0.0.1:6379> MSET key1 val1 key2 val2 key3 val3   # mset  同时设置多个值
OK
127.0.0.1:6379> keys *
1) "key2"
2) "key3"
3) "key1"
127.0.0.1:6379> MGET key1 key2 key3  # mget  同时获取多个值
1) "val1"
2) "val2"
3) "val3"
127.0.0.1:6379> MSETNX key1 val123 key4 val4   # msetnx 是一个原子性的操作，要么一起成功，要么一起 失败
(integer) 0
127.0.0.1:6379> get key4
(nil)
```

### 2.7 对象
**语法：**

设置对象：`SET KEY1：KEY2：KEY3 VALUE`

**举例：**
```bash
# 设置一个“user:1”的对象 值是一个json字符来保存对象！
127.0.0.1:6379> set user:1 {name:zhangsan,age:27}
OK
127.0.0.1:6379> keys *
1) "user:1"
2) "key2"
3) "key3"
4) "key1"
127.0.0.1:6379> get user:1
"{name:zhangsan,age:27}"

## 批量设置key（user:{id}:{filed}）和值
127.0.0.1:6379> mset user:1:name xiaohua user:1:age 28
OK
127.0.0.1:6379> keys *
1) "key2"
2) "key3"
3) "user:1:name"
4) "key1"
5) "user:1"
6) "user:1:age"
127.0.0.1:6379> mget user:1:name user:1:age
1) "xiaohua"
2) "28"
```

### 2.8 组合命令
**语法：**

先取值再赋值：`GETSET  KEY VALUE`

**举例：**

```bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> GETSET db redis  # 如果不存在值，则返回 nil
(nil)
127.0.0.1:6379> get db
"redis"
127.0.0.1:6379> GETSET db mysql  # 如果存在值，获取原来的值，并设置新的值
"redis"
127.0.0.1:6379> keys *
1) "db"
127.0.0.1:6379> get db
"mysql"
```

### 2.9 应用总结
数据结构是相同的！ 
String类似的使用场景：value除了是我们的字符串还可以是我们的数字！

 - 计数器 
 - 统计多单位的数量 
 - 粉丝数 
 - 对象缓存存储！

## 3、List（列表）
基本的数据类型，列表

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210420151745366.png)
在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列！ 

**所有的list命令都是用`l`开头的** 

### 3.1 插入，获取，查看
**语法：**

将一个值(多个值)从头部（左边）插入：`LPUSH  KEY ELEMENT [ELEMENT.......]`
将一个值(多个值)从右边插入：`RPUSH  KEY ELEMENT [ELEMENT.......]`
获取LIST的值：`LRANGE KEY START END  （0 -1 代表全部）`

**举例：**
```bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> LPUSH list one # 将一个值或者多个值，插入到列表头部（左边）
(integer) 1
127.0.0.1:6379> LPUSH list two
(integer) 2
127.0.0.1:6379> LPUSH list three
(integer) 3
127.0.0.1:6379> LRANGE list 0 -1  # 获取list中所有的值！
1) "three"
2) "two"
3) "one"
127.0.0.1:6379> LRANGE list 0 1   # 通过区间获取具体的值！
1) "three"
2) "two"
127.0.0.1:6379> RPUSH list rightval  # 将一个值或者多个值，插入到列表位的右边
(integer) 4
127.0.0.1:6379> LRANGE list 0 -1  
1) "three"
2) "two"
3) "one"
4) "rightval"
127.0.0.1:6379> LPUSH newlist val1 val2  # 从左边插入两个值
(integer) 2
127.0.0.1:6379> LRANGE newlist 0 -1
1) "val2"
2) "val1"
127.0.0.1:6379> RPUSH newlist val3 val4  # 从右边插入两个值
(integer) 4
127.0.0.1:6379> LRANGE newlist 0 -1
1) "val2"
2) "val1"
3) "val3"
4) "val4"
```

### 3.2 移除
**语法：**

从左边移除值：`LPOP KEY [COUNT]`
从右边移除值：`RPOP KEY [COUNT]`


**举例：**
```bash
127.0.0.1:6379> keys *
1) "list"
127.0.0.1:6379> LRANGE list 0 -1
 1) "ten"
 2) "nine"
 3) "eight"
 4) "seveen"
 5) "six"
 6) "five"
 7) "flour"
 8) "threee"
 9) "two"
10) "one"
127.0.0.1:6379> LPOP list  # 移除list的第一个元素
"ten"
127.0.0.1:6379> LRANGE list 0 -1
1) "nine"
2) "eight"
3) "seveen"
4) "six"
5) "five"
6) "flour"
7) "threee"
8) "two"
9) "one"
127.0.0.1:6379> RPOP list # 移除list的最后一个元素
"one"
127.0.0.1:6379> LRANGE list 0 -1
1) "nine"
2) "eight"
3) "seveen"
4) "six"
5) "five"
6) "flour"
7) "threee"
8) "two"
127.0.0.1:6379> LPOP list 2  # 移除list的开头的两个元素
1) "nine"
2) "eight"
127.0.0.1:6379> LRANGE list 0 -1
1) "seveen"
2) "six"
3) "five"
4) "flour"
5) "threee"
6) "two"
127.0.0.1:6379> RPOP list 3  # 移除list的末尾的3个元素
1) "two"
2) "threee"
3) "flour"
127.0.0.1:6379> LRANGE list 0 -1
1) "seveen"
2) "six"
3) "five"
```

### 3.3 通过下标获取值
**语法：**

通过下标获取list的值：`LINDEX KEY INDEX`

**举例：**
```bash
127.0.0.1:6379> LPUSH list val1 val2 val3 val4 val5
(integer) 5
127.0.0.1:6379> LRANGE list 0 -1
1) "val5"
2) "val4"
3) "val3"
4) "val2"
5) "val1"
127.0.0.1:6379> LINDEX list 2    # 通过下标获得 list 中的某一个值！ 
"val3"
127.0.0.1:6379> LINDEX list 1
"val4"
127.0.0.1:6379> LINDEX list 0
"val5"
127.0.0.1:6379> LINDEX list -1
"val1"
```

### 3.4 获取列表长度
**语法：**

获取list列表的长度：`LLEN KEY`

**举例：**
```bash
127.0.0.1:6379> LPUSH list lval1 lval2 lval3
(integer) 3
127.0.0.1:6379> LRANGE list 0 -1
1) "lval3"
2) "lval2"
3) "lval1"
127.0.0.1:6379> LLEN list  # 返回列表的长度
(integer) 3
127.0.0.1:6379> LPUSH list lval4 lval5
(integer) 5
127.0.0.1:6379> LLEN list
(integer) 5
```

### 3.5 移除指定的值
**语法：**

移除指定的值：`LREM KEY COUNT ELEMENT`

**举例：**
```bash
127.0.0.1:6379> LRANGE list 0 -1
1) "three"
2) "three"
3) "two"
4) "one"
127.0.0.1:6379> lrem list 1 one  # 移除list集合中指定个数的value，精确匹配 (integer) 1
127.0.0.1:6379> LRANGE list 0 -1
1) "three"
2) "three"
3) "two"
127.0.0.1:6379> lrem list 1 three
(integer) 1
127.0.0.1:6379> LRANGE list 0 -1
1) "three"
2) "two"
127.0.0.1:6379> Lpush list three
(integer) 3
127.0.0.1:6379> lrem list 2 three
(integer) 2
127.0.0.1:6379> LRANGE list 0 -1
1) "two"
```

### 3.6 截取list
**语法：**

截取list的值：`LTRIM KEY START STOP`

**举例：**
```bash
127.0.0.1:6379> LPUSH list one two three flour five
(integer) 5
127.0.0.1:6379> LRANGE list 0 -1
1) "five"
2) "flour"
3) "three"
4) "two"
5) "one"
127.0.0.1:6379> LTRIM list 1 2  # 通过下标截取指定的长度，这个list已经被改变了，截断了，只剩下截取的元素！
OK
127.0.0.1:6379> LRANGE list 0 -1 
1) "flour"
2) "three"
```

### 3.7 移除列表元素，到新列表中
**语法：**

移除列表元素，到新列表中：`RPOPLPUSH SOURCE DESTINATION`

**举例：**
```bash
127.0.0.1:6379> keys *
1) "list"
127.0.0.1:6379> LRANGE list 0 -1
1) "one"
2) "two"
3) "three"
4) "flour"
5) "five"
127.0.0.1:6379> RPOPLPUSH list newList  # 移除列表的最后一个元素，将他移动到新的列表中！
"five"
127.0.0.1:6379> KEYS *
1) "newList"
2) "list"
127.0.0.1:6379> LRANGE list 0 -1  # 查看原来的列表
1) "one"
2) "two"
3) "three"
4) "flour"
127.0.0.1:6379> LRANGE newList 0 -1  # 查看目标列表中，确实存在改值！
1) "five"
```

### 3.8 指定值的替换（更新）
**语法：**

替换指定的值，更新操作：`LSET KEY INDEX ELEMENT`

**举例：**
```bash
# lset  将列表中指定下标的值替换为另外一个值，更新操作
127.0.0.1:6379> EXISTS list  # 判断这个列表是否存在
(integer) 0
127.0.0.1:6379> lset list 0 item   # 如果不存在列表我们去更新就会报错
(error) ERR no such key
127.0.0.1:6379> lpush list value1
(integer) 1
127.0.0.1:6379> LRANGE list 0 0
1) "value1"
127.0.0.1:6379> lset list 0 item   # 如果存在，更新当前下标的值
OK
127.0.0.1:6379> LRANGE list 0 0
1) "item"
127.0.0.1:6379> lset list 1 other    # 如果不存在，则会报错！
(error) ERR index out of range 
```

### 3.9 值插入具体位置
**语法：**

具体位置插入值：`LINSERT KEY BEFORE/AFTER PIVOT ELEMENT`

**举例：**
```bash
# linsert # 将某个具体的value插入到列把你中某个元素的前面或者后面！
127.0.0.1:6379> Rpush mylist "hello"
(integer) 1
127.0.0.1:6379> Rpush mylist "world"
(integer) 2
127.0.0.1:6379> LINSERT mylist before "world" "other"
(integer) 3
127.0.0.1:6379> LRANGE mylist 0 -1
1) "hello"
2) "other"
3) "world"
127.0.0.1:6379> LINSERT mylist after world new 
(integer) 4
127.0.0.1:6379> LRANGE mylist 0 -1
1) "hello"
2) "other"
3) "world"
4) "new"
```

### 3.10 应用总结
- 他实际上是一个链表，before Node after ， left，right 都可以插入值 
- 如果key 不存在，创建新的链表
- 如果key存在，新增内容
- 如果移除了所有值，空链表，也代表不存在！ 
- 在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~

> 	 可以实现场景：消息排队！消息队列  （Lpush  Rpop），   栈（  Lpush  Lpop）！

## 4、Set（集合）

**set中的值是不能重读的！**

### 4.1 插入，获取，查看
**语法：**

在Set集合中添加值：`SADD KEY MEMBER [MEMBER ......]`
查看Set集合中的所有值：`SMEMBERS KEY`
查看值是否在Set集合中：`SISMEMBER KEY MEMBER`

**举例：**
```bash
127.0.0.1:6379> SADD myset java  # set集合中添加值
(integer) 1
127.0.0.1:6379> SADD myset phthon
(integer) 1
127.0.0.1:6379> SADD myset php
(integer) 1
127.0.0.1:6379> KEYS *
1) "myset"
127.0.0.1:6379> SMEMBERS myset # 查看指定set的所有值
1) "php"
2) "phthon"
3) "java"
127.0.0.1:6379> SISMEMBER myset java  # 判断某一个值是不是在set集合中！ 
(integer) 1
127.0.0.1:6379> SISMEMBER myset C++
(integer) 0
```

### 4.2 获取元素个数
**语法：**

获取Set的元素个数：`SCARD KEY`

**举例：**
```bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> sadd myset member1
(integer) 1
127.0.0.1:6379> sadd myset member2 member3 member4 member5
(integer) 4
127.0.0.1:6379> SCARD myset  # 获取set集合中的内容元素个数！
(integer) 5
```

### 4.3 移除指定元素
**语法：**

移除指定元素：`SREM KEY MEMBER [MEMBER ......]`

**举例：**
```bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> sadd myset member1
(integer) 1
127.0.0.1:6379> sadd myset member2 member3 member4 member5
(integer) 4
127.0.0.1:6379> SREM myset member123
(integer) 0
127.0.0.1:6379> SREM myset member1 # 移除set集合中的指定元素
(integer) 1
127.0.0.1:6379> SMEMBERS myset
1) "member2"
2) "member5"
3) "member4"
4) "member3"
```

.
### 4.4 随机抽选元素
**语法：**

随机抽选元素：`SRANDMEMBER KEY [COUNT]`

**举例：**
```bash
127.0.0.1:6379> SMEMBERS myset
1) "mem2"
2) "mem4"
3) "mem1"
4) "mem3"
5) "mem5"
127.0.0.1:6379> SRANDMEMBER myset # 随机抽选出一个元素
"mem2"
127.0.0.1:6379> SRANDMEMBER myset
"mem1"
127.0.0.1:6379> SRANDMEMBER myset
"mem3"
127.0.0.1:6379> SRANDMEMBER myset
"mem4"
127.0.0.1:6379> SRANDMEMBER myset
"mem5"
127.0.0.1:6379> SRANDMEMBER myset
"mem3"
127.0.0.1:6379> SRANDMEMBER myset 2  # 随机抽选出指定个数的元素
1) "mem5"
2) "mem3"
127.0.0.1:6379> SRANDMEMBER myset 3
1) "mem2"
2) "mem4"
3) "mem1"
127.0.0.1:6379> SRANDMEMBER myset 2
1) "mem5"
2) "mem2"
```

### 4.5 随机删除元素
**语法：**

随机删除元素：`SPOP KEY [COUNT]`

**举例：**
```bash
127.0.0.1:6379> SMEMBERS myset
1) "mem2"
2) "mem5"
3) "mem4"
4) "mem1"
5) "mem3"
127.0.0.1:6379> SPOP myset  # 随机删除一些set集合中的元素！ 
"mem4"
127.0.0.1:6379> SPOP myset 2
1) "mem5"
2) "mem3"
127.0.0.1:6379> SMEMBERS myset
1) "mem2"
2) "mem1"
```

### 4.6 移动
**语法：**

移动元素到新的set集合中：`SMOVE SOURCE DESTINATION MEMBER`

**举例：**
```bash
127.0.0.1:6379> SMEMBERS myset
1) "m1"
2) "m4"
3) "m3"
4) "m6"
5) "m2"
6) "m5"
127.0.0.1:6379> SMOVE myset newSet m2  # 将一个指定的值，移动到另外一个set集合！
(integer) 1
127.0.0.1:6379> SMOVE myset newSet m2
(integer) 0
127.0.0.1:6379> SMEMBERS myset
1) "m3"
2) "m1"
3) "m6"
4) "m4"
5) "m5"
127.0.0.1:6379> SMEMBERS newSet
1) "m2"
```

### 4.7 集合
微博，B站，共同关注！(并集)

数字集合类：
 - 差集 `SDIFF`
 - 交集 `SINTER` 
 - 并集 `SUNION` 

```bash
127.0.0.1:6379> SMEMBERS set1
1) "m3"
2) "m2"
3) "m1"
4) "m4"
5) "m5"
127.0.0.1:6379> SMEMBERS set2
1) "m2"
2) "m7"
3) "m8"
127.0.0.1:6379> SDIFF set1 set2 # 差集
1) "m3"
2) "m1"
3) "m5"
4) "m4"
127.0.0.1:6379> SDIFF set2 set1 # 差集
1) "m7"
2) "m8"
127.0.0.1:6379> SINTER set1 set2 # 交集 
1) "m2"
127.0.0.1:6379> SINTER set2 set1 # 交集 
1) "m2"
127.0.0.1:6379> SUNION set1 set2 # 并集
1) "m3"
2) "m7"
3) "m1"
4) "m2"
5) "m4"
6) "m5"
7) "m8"
127.0.0.1:6379> SUNION set2 set1 # 并集
1) "m3"
2) "m7"
3) "m1"
4) "m2"
5) "m5"
6) "m4"
7) "m8"
```

### 4.8 应用总结
微博，A用户将所有关注的人放在一个set集合中！将它的粉丝也放在一个集合中！ 

共同关注，共同爱好，二度好友，推荐好友！（六度分割理论）


## 5、Hash（哈希）
可以看做Map集合，key-map!  时候这个值是一个map集合！ 

本质和String类型没有太大区别，还是一个简单的 key-vlaue！

### 5.1 插入，获取，查看
**语法：**

Hash插入值：`HSET KEY FIELD VALUE [FIELD VALUE......]`
Hash获取值：`HGET KEY FIELD`
Hash批量插入值：`HMSET KEY FIELD VALUE [FIELD VALUE......]`
Hash批量获取值：`HMGET KEY FIELD [FIELD......]`
Hash获取所有的值：`HGETALL KEY`

**举例：**
```bash
127.0.0.1:6379> hset myhash field1 kuangshen  # set一个具体 key-vlaue
(integer) 1
127.0.0.1:6379> hget myhash field1  # 获取一个字段值
"kuangshen"
127.0.0.1:6379> hmset myhash field1 hello field2 world   # set多个 key-vlaue
OK
127.0.0.1:6379> hmget myhash field1 field2   # 获取多个字段值
1) "hello"
2) "world"
127.0.0.1:6379> hgetall myhash   # 获取全部的数据，
1) "field1"
2) "hello"
3) "field2"
4) "world"
```

### 5.2 删除元素
**语法：**

Hash删除元素：`HDEL KEY FIELD [FIELD......]`

**举例：**
```bash
127.0.0.1:6379> HGETALL myHash
1) "f1"
2) "v1"
3) "f2"
4) "v2"
5) "f3"
6) "v3"
127.0.0.1:6379> HDEL myHash f2  # 删除hash指定key字段！对应的value值也就消失了！ 
(integer) 1
127.0.0.1:6379> HGETALL myHash
1) "f1"
2) "v1"
3) "f3"
4) "v3"
```


### 5.3 获取元素数量
**语法：**

Hash元素的数量获取：`HLEN KEY`

**举例：**
```bash
127.0.0.1:6379> HGETALL myHash
1) "f1"
2) "v1"
3) "f3"
4) "v3"
127.0.0.1:6379> HLEN myHash # 获取hash表的字段数量！
(integer) 2
```


### 5.4 判断元素存在
**语法：**

判断Hash中元素是否存在：`HEXISTS KEY FIELD`

**举例：**
```bash
127.0.0.1:6379> HGETALL myHash
1) "f1"
2) "v1"
3) "f3"
4) "v3"
127.0.0.1:6379> HEXISTS myHash f1 # 判断hash中指定字段是否存在！
(integer) 1
127.0.0.1:6379> HEXISTS myHash f6
(integer) 0
```

### 5.5 获取所有元素，获取所有值
**语法：**

获取Hash中所有元素：`HKEYS KEY`
获取Hash中所有元素的值：`HVALS KEY`

**举例：**
```bash
# 只获得所有field
# 只获得所有value
127.0.0.1:6379> HGETALL myHash
1) "f1"
2) "v1"
3) "f3"
4) "v3"
127.0.0.1:6379> HKEYS myHash # 只获得所有field
1) "f1"
2) "f3"
127.0.0.1:6379> HVALS myHash # 只获得所有value
1) "v1"
2) "v3"
```

### 5.6 自增 自减
**语法：**

Hash中元素自增：`HINCRBY KEY FIELD INCREMENT（正数）`
Hash中元素自减：`HINCRBY KEY FIELD INCREMENT（负数）`

**举例：**
```bash
# incr   decr
127.0.0.1:6379> hset myhash field3 5    #指定增量！
(integer) 1
127.0.0.1:6379> HINCRBY myhash field3 1   # 自增
(integer) 6
127.0.0.1:6379> HINCRBY myhash field3 -1  #自减
(integer) 5
127.0.0.1:6379> hsetnx myhash field4 hello  # 如果不存在则可以设置 (integer) 1
127.0.0.1:6379> hsetnx myhash field4 world  # 如果存在则不能设置 (integer) 0
```

### 5.7 是否存在
**语法：**

Hash中元素是否存在：`HSETNX KEY FIELD VALUE`

**举例：**
```bash
127.0.0.1:6379> HGETALL myHash
1) "f1"
2) "v1"
3) "f2"
4) "v2"
5) "f3"
6) "v3"
127.0.0.1:6379> HSETNX myHash f4 v4 # 如果不存在则可以设置 
(integer) 1
127.0.0.1:6379> HGETALL myHash
1) "f1"
2) "v1"
3) "f2"
4) "v2"
5) "f3"
6) "v3"
7) "f4"
8) "v4"
127.0.0.1:6379> HSETNX myHash f1 v99  # 如果存在则不能设置 
(integer) 0
127.0.0.1:6379> HSETNX myHash f1 v1
(integer) 0
```

### 5.8 应用总结
- hash变更的数据 user  name  age,尤其是是用户信息之类的，经常变动的信息！
-  hash 更适合于对象的 存储
-  String更加适合字符串存储！

## 6、Zset（有序集合）
在set的基础上，增加了一个值，set k1 v1   zset k1 score1 v1

### 6.1 添加、获取
**语法：**

添加值：`ZADD KEY` 
获取：`ZRANGE  KEY MIN MAX`

**举例：**
```bash
127.0.0.1:6379> zadd myset 1 one     # 添加一个值 
(integer) 1
127.0.0.1:6379> zadd myset 2 two 3 three   # 添加多个值 
(integer) 2
127.0.0.1:6379> ZRANGE myset 0 -1
1) "one"
2) "two"
3) "three"
```

### 6.2 排序
**语法：**

从小到大排列值：`ZRANGEBYSCORE KEY -inf +inf` 
从大到小排列值：`ZREVRANGE KEY  0 -1`
按条件显示值的所有信息：`ZRANGEBYSCORE KEY -inf +inf WiTHSCORES`

**举例：**
```bash
127.0.0.1:6379> ZADD salary 2500 xiaohong  # 添加三个用户,包含他们的工资。
(integer) 1
127.0.0.1:6379> ZADD salary 3000 zhangsan
(integer) 1
127.0.0.1:6379> ZADD salary 600 xiaoR
(integer) 1
127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf  # 显示全部的用户工资，从小到大排序！
1) "xiaoR"
2) "xiaohong"
3) "zhangsan"
127.0.0.1:6379> ZREVRANGE salary 0 -1  # 显示全部的用户工资，从大到小排序！
1) "zhangsan"
2) "xiaohong"
3) "xiaoR"
127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf WiTHSCORES  # 显示全部的用户并且附带成绩
1) "xiaoR"
2) "600"
3) "xiaohong"
4) "2500"
5) "zhangsan"
6) "3000"
127.0.0.1:6379> ZRANGEBYSCORE salary -inf 2500 WITHSCORES  # 显示工资小于2500员工，并按升序排序！
1) "xiaoR"
2) "600"
3) "xiaohong"
4) "2500"
```

### 6.3 移除
**语法：**

移除元素：`ZREM KEY MEMBER [MEMBER .......]` 
获取zset的元素的个数：`ZCARD KEY `

**举例：**
```bash
127.0.0.1:6379> ZRANGE salary 0 -1
1) "xiaoR"
2) "xiaohong"
3) "zhangsan"
127.0.0.1:6379> ZREM salary xiaohong  # 移除有序集合中的指定元素
(integer) 1
127.0.0.1:6379> ZRANGE salary 0 -1
1) "xiaoR"
2) "zhangsan"
127.0.0.1:6379> ZCARD salary  # 获取有序集合中元素的个数
(integer) 2
```

### 6.4 获取指定区间元素个数
**语法：**

获取指定区间的成员数量的个数：`ZCOUNT KEY  MIN MAX`

**举例：**
```bash
127.0.0.1:6379> zadd myset 1 hello
(integer) 1
127.0.0.1:6379> zadd myset 2 world 3 xiaoR
(integer) 2
127.0.0.1:6379> ZCOUNT myset 1 3  # 获取指定区间的成员数量！
(integer) 3
127.0.0.1:6379> ZCOUNT myset 1 2
(integer) 2
```

### 6.5 应用总结
其与的一些API，通过我们的学习吗，你们剩下的如果工作中有需要，这个时候你可以去查查看官方文 档！

案例思路：set  排序   存储班级成绩表，工资表排序！ 

普通消息，1， 重要消息 2，带权重进行判断！ 

排行榜应用实现，取Top N 测试！


# 四、三种特殊数据类型
## 1、Geospatial 地理位置
朋友的定位，附近的人，打车距离计算？

Redis 的 Geo 在Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆 几里的人！

该数据类型的操作只有 六个命令：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421105628839.png)

官方文档：[https://www.redis.net.cn/order/3685.html](https://www.redis.net.cn/order/3685.html)

### 1.1 GEOADD

```bash
# geoadd 添加地理位置
# 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！ 
# 有效的经度从-180度到180度。
# 有效的纬度从-85.05112878度到85.05112878度。
# 当坐标位置超出上述指定范围时，该命令将会返回一个错误。
    # 127.0.0.1:6379> geoadd china:city 39.90 116.40 beijin (error) 
# ERR invalid longitude,latitude pair 39.900000,116.400000

# 参数 key  值（）
127.0.0.1:6379> geoadd china:city 116.40 39.90 beijing
(integer) 1
127.0.0.1:6379> geoadd china:city 121.47 31.23 shanghai
(integer) 1
127.0.0.1:6379> geoadd china:city 106.50 29.53 chongqi 114.05 22.52 shengzhen 
(integer) 2
127.0.0.1:6379> geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian 
(integer) 2
```

### 1.2 GEOPOS
获得当前定位：一定是一个坐标值！

```bash
127.0.0.1:6379> GEOPOS china:city beijing  # 获取指定的城市的经度和纬度！ 
1) 1) "116.39999896287918091"
   2) "39.90000009167092543"
127.0.0.1:6379> GEOPOS china:city beijing chongqi
1) 1) "116.39999896287918091"
   2) "39.90000009167092543"
2) 1) "106.49999767541885376"
   2) "29.52999957900659211"
```

### 1.3 GEODIST
两人之间的距离！ 

单位：
- m 表示单位为米。
- km 表示单位为千米。 
- mi 表示单位为英里。 
- ft 表示单位为英尺。

```bash
127.0.0.1:6379> GEODIST china:city beijing shanghai km  # 查看上海到北京的直线距离 
"1067.3788"
127.0.0.1:6379> GEODIST china:city beijing chongqi km   # 查看重庆到北京的直线距离 
"1464.0708"
```

### 1.4 GEORADIUS
以给定的经纬度为中心， 找出某一半径内的元素。

我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！ 
获得指定数量的人，200
所有数据应该都录入：china:city ，才会让结果更加请求！

```bash
127.0.0.1:6379> GEORADIUS china:city 110 30 1000 km  # 以110，30 这个经纬度为中心，寻 找方圆1000km内的城市
1) "chongqi"
2) "xian"
3) "shengzhen"
4) "hangzhou"
127.0.0.1:6379> GEORADIUS china:city 110 30 500 km
1) "chongqi"
2) "xian"
127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withdist  # 显示到中间距离的位置 
1) 1) "chongqi"
   2) "341.9374"
2) 1) "xian"
   2) "483.8340"
127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withcoord  # 显示他人的定位信息
1) 1) "chongqi"
   2) 1) "106.49999767541885376"
      2) "29.52999957900659211"
2) 1) "xian"
   2) 1) "108.96000176668167114"
      2) "34.25999964418929977"
127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withdist withcoord count 1  # 筛选出指定的结果！
1) 1) "chongqi"
   2) "341.9374"
   3) 1) "106.49999767541885376"
      2) "29.52999957900659211"
127.0.0.1:6379> GEORADIUS china:city 110 30 500 km withdist withcoord count 2
1) 1) "chongqi"
   2) "341.9374"
   3) 1) "106.49999767541885376"
      2) "29.52999957900659211"
2) 1) "xian"
   2) "483.8340"
   3) 1) "108.96000176668167114"
      2) "34.25999964418929977"
```

### 1.5 GEORADIUSBYMEMBER

```bash
# 找出位于指定元素周围的其他元素！
127.0.0.1:6379> GEORADIUSBYMEMBER china:city beijing 1000 km 
1) "beijing"
2) "xian"
127.0.0.1:6379> GEORADIUSBYMEMBER china:city shanghai 400 km 
1) "hangzhou"
2) "shanghai"
```

### 1.6 GEOHASH
返回一个或多个位置元素的 Geohash 表示

该命令将返回11个字符的Geohash字符串!

```bash
# 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！ 
127.0.0.1:6379> geohash china:city beijing chongqi
1) "wx4fbxxfke0"
2) "wm5xzrybty0"
```

**GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo！**

### 1.7 查看  移除

```bash
127.0.0.1:6379> ZRANGE china:city 0 -1  # 查看地图中全部的元素 
1) "chongqi"
2) "xian"
3) "shengzhen"
4) "hangzhou"
5) "shanghai"
6) "beijing"
127.0.0.1:6379> zrem china:city beijing  # 移除指定元素！ (integer) 1
127.0.0.1:6379> ZRANGE china:city 0 -1
1) "chongqi"
2) "xian"
3) "shengzhen"
4) "hangzhou"
5) "shanghai"
```

## 2、Hyperloglog
### 2.1 什么是基数？

A {1,3,5,7,8,7}
B{1，3,5,7,8}
基数（不重复的元素）  = 5，可以接受误差！

### 2.2 简介
Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！ 
Redis Hyperloglog  基数统计的算法！

优点：占用的内存是固定，2^64 不同的元素的基数，只需要废 12KB内存！如果要从内存角度来比较的 话 Hyperloglog 首选！

网页的 UV （一个人访问一个网站多次，但是还是算作一个人！）

传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 ! 
这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id； 
0.81% 错误率！ 统计UV任务，可以忽略不计的！

### 2.3 测试使用

```bash
127.0.0.1:6379> PFadd mykey a b c d e f g h i j   # 创建第一组元素 mykey
(integer) 1
127.0.0.1:6379> PFCOUNT mykey  # 统计 mykey 元素的基数数量
(integer) 10
127.0.0.1:6379> PFadd mykey2 i j z x c v b n m   # 创建第二组元素 mykey2
(integer) 1
127.0.0.1:6379> PFCOUNT mykey2
(integer) 9
127.0.0.1:6379> PFMERGE mykey3 mykey mykey2  # 合并两组 mykey mykey2 => mykey3 并集 
OK
127.0.0.1:6379> PFCOUNT mykey3  # 看并集的数量！
(integer) 15
```

如果允许容错，那么一定可以使用 Hyperloglog  ！ 
如果不允许容错，就使用 set 或者自己的数据类型即可！

## 3、Bitmap
为什么其他教程都不喜欢讲这些？这些在生活中或者开发中，都有十分多的应用场景，学习了，就是就 是多一个思路！

**位存储**

统计用户信息，活跃，不活跃！  登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用 Bitmaps！

Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！ 

365 天 = 365 bit   1字节 = 8bit    46 个字节左右！


**测试**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421112537675.png)

使用bitmap 来记录 周一到周日的打卡！
 周一：1   周二：0  周三：0  周四：1 ......

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421112616867.png)

查看某一天是否有打卡！

```bash
127.0.0.1:6379> getbit sign 3 
(integer) 1
127.0.0.1:6379> getbit sign 6 
(integer) 0
```

统计操作，统计 打卡的天数！
bitcount :统计值是1的数量

```bash
127.0.0.1:6379> bitcount sign  # 统计这周的打卡记录，就可以看到是否有全勤！ 
(integer) 3
```

# 五、事务

Redis 事务本质：一组命令的集合！  一个事务中的所有命令都会被序列化，在事务执行过程的中，会按 照顺序执行！

一次性、顺序性、排他性！执行一些列的命令！


<font color = red> Redis事务没有没有隔离级别的概念！ 

所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！

<font color = red>Exec Redis单条命令式保存原子性的，但是事务不保证原子性！


redis的事务：
- 开启事务：MULTI
- 命令入队（......） 
- 取消事务：DISCARD   
- 执行事务：EXEC


## 1、正常执行事务

```bash
127.0.0.1:6379> multi    # 开启事务 
OK
# 命令入队
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2 
QUEUED
127.0.0.1:6379> get k2
QUEUED
127.0.0.1:6379> set k3 v3 
QUEUED
127.0.0.1:6379> exec  # 执行事务  可以发现所有命令是执行exec后同一执行的
1) OK
2) OK
3) "v2"
4) OK
```

## 2、放弃事务

```bash
127.0.0.1:6379> multi   # 开启事务
OK
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> set k4 v4
QUEUED
127.0.0.1:6379> DISCARD   # 取消事务
OK
127.0.0.1:6379> get k4  # 事务队列中命令都不会被执行！ 
(nil)
```

## 3、编译型异常

编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！

```bash
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> set k3 v3
QUEUED
127.0.0.1:6379> getset k3    # 执行错误的命令
(error) ERR wrong number of arguments for 'getset' command 127.0.0.1:6379> set k4 v4
QUEUED
127.0.0.1:6379> set k5 v5
QUEUED
127.0.0.1:6379> exec  # 执行事务报错！
(error) EXECABORT Transaction discarded because of previous errors. 127.0.0.1:6379> get k5  # 所有的命令都不会被执行！
(nil)
```

## 4、运行时异常
运行时异常（1/0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行 的，错误命令抛出异常！

```bash
127.0.0.1:6379> set k1 "v1"
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> incr k1  # 会执行的时候失败！
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> set k3 v3
QUEUED
127.0.0.1:6379> get k3
QUEUED
127.0.0.1:6379> exec
1) (error) ERR value is not an integer or out of range  # 虽然第一条命令报错了，但是 依旧正常执行成功了！
2) OK
3) OK
4) "v3"
127.0.0.1:6379> get k2
"v2"
127.0.0.1:6379> get k3
"v3"
```

## 5、监控（面试常问）
**悲观锁：** 
- 很悲观，认为什么时候都会出问题，无论做什么都会加锁！

**乐观锁：**
- 很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否有人修改过这个数据， 
- 获取version 
- 更新的时候比较 version


**Redis测监视测试:**

正常执行成功！

```bash
127.0.0.1:6379> set money 100
OK
127.0.0.1:6379> set out 0
OK
127.0.0.1:6379> watch money   # 监视 money 对象
OK
127.0.0.1:6379> multi     # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！ OK
127.0.0.1:6379> DECRBY money 20
QUEUED
127.0.0.1:6379> INCRBY out 20
QUEUED
127.0.0.1:6379> exec
1) (integer) 80
2) (integer) 20
```

测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！

```bash
127.0.0.1:6379> watch money   # 监视  money
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> DECRBY money 10
QUEUED
127.0.0.1:6379> INCRBY out 10
QUEUED
127.0.0.1:6379> exec  # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失败！
(nil)
```

如果修改失败，获取最新的值就好!

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210421113855594.png)

# 六、Jedis


什么是Jedis  是 Redis 官方推荐的 java连接开发工具！ 
使用Java 操作Redis 中间件！如果你要使用 java操作redis，那么一定要对Jedis 十分的熟悉！

## 1、测试jedis
### 1.1 新建jedis项目

新建一个maven项目即可
![在这里插入图片描述](https://img-blog.csdnimg.cn/b01e7ca1cdb4433fbd2a6554df5c8982.png)
### 1.2 导入依赖包
打开maven官网，找到jedis依赖

地址：https://mvnrepository.com/search?q=jedis
![在这里插入图片描述](https://img-blog.csdnimg.cn/9ccd018088cd4b1c959e8d78f5546e1a.png)
### 1.3 编码测试

- 连接数据库
- 操作命令
- 断开连接！

常用的API：String、List、Set、Hash、Zset

# 七、整合SpringBoot

- SpringBoot 操作数据：spring-data jpa jdbc mongodb redis！
- SpringData 也是和 SpringBoot 齐名的项目！
- 说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce

**对比：**
- jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接池！ 更像 BIO 模式
- lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像 NIO 模式。。。lettuce 底层导入的是netty包，性能更快一点！！！

## 1、有关依赖
操作redis，引入redis依赖：

```xml
<!--  操作redis  -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

进入spring-boot-starter-data-redis底层，发现底层就是spring-data-redis

底层用的不是jedis，而是lettuce。这个是SpringBoot2.x之后就替换了。


![在这里插入图片描述](https://img-blog.csdnimg.cn/b7a24fb8d0d5415fbe329d7c80bda5ac.png)

进入lettuce-core底层以后：可以看到	io.netty的相关依赖

## 2、配置文件
SpringBoot配置文件：

```bash
# SpringBoot所有的配置类，都有一个自动配置类，RedisAutoConfiguration
# 自动配置类（RedisAutoConfiguration）都会绑定一个properties配置文件，RedisProperties

# 在这里面可以配置以下东西：都是RedisProperties类里面的属性
    #private int database = 0;   //默认数据库
    #private String url;
    #private String host = "localhost";
    #private String username;
    #private String password;
    #private int port = 6379;
    #private boolean ssl;
    #private Duration timeout;
    #private Duration connectTimeout;
    #private String clientName;
    #private RedisProperties.ClientType clientType;
    #private RedisProperties.Sentinel sentinel;
    #private RedisProperties.Cluster cluster;


spring.redis.host= 127.0.0.1
spring.redis.port=6379
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/0da08005ac5d4248951517b48e77085b.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/43080de2bdc3479b8cd9dc0259a3adb8.png)

## 3、部分源码解读

RedisAutoConfiguration类源码分析：

```java
@Configuration(
    proxyBeanMethods = false
)
@ConditionalOnClass({RedisOperations.class})
@EnableConfigurationProperties({RedisProperties.class})
@Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class})
public class RedisAutoConfiguration {
    public RedisAutoConfiguration() {
    }

    @Bean
    @ConditionalOnMissingBean(
        name = {"redisTemplate"}
    )   // 我们可以自己定义一个redisTemplate来替换这个默认的！ 
    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
     // 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！    
     // 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 <String, Object>
        RedisTemplate<Object, Object> template = new RedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }

    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)  // 由于 String 是redis中最常使用的类型，所以说单独提出来了一个方法。
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
        return new StringRedisTemplate(redisConnectionFactory);
    }
}
```

进入RedisAutoConfiguration类中的RedisConnectionFactory：

发现会有两个

![在这里插入图片描述](https://img-blog.csdnimg.cn/fd42b95aa27043a98206ed76b61cd074.png)
进入JedisConnectionFactory，下载源码，发现报红，很多都不生效的
![在这里插入图片描述](https://img-blog.csdnimg.cn/da7083c47ac141d89ddb2181524074bd.png)

进入LettuceConnectionFactory，发现都是生效的

![在这里插入图片描述](https://img-blog.csdnimg.cn/441c0fb8a51141119fe9f83284e41c60.png)

## 4、整合测试
测试redis的RedisTemplate：

![在这里插入图片描述](https://img-blog.csdnimg.cn/87cbb0d091524931b9f55ca40d80ca27.png)
输出xiaoR
![在这里插入图片描述](https://img-blog.csdnimg.cn/f4c081db872648869d2b2e2b36468899.png)

进入RedisTemplate类中：

![在这里插入图片描述](https://img-blog.csdnimg.cn/34d4b0b139ff43f992544595eced5516.png)

然后新建一个user对象：

先不序列化

![在这里插入图片描述](https://img-blog.csdnimg.cn/c46fad3edcf749b784201ec1e0a98a6d.png)
测试：
![在这里插入图片描述](https://img-blog.csdnimg.cn/6871e64f43dc46c1985fca1c7d68a131.png)
结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/87a1b7a12a9e4c2fbfe0990a4a372b5b.png)

不序列话，直接传对象的话：
![在这里插入图片描述](https://img-blog.csdnimg.cn/51f9c3ef86a040538854f55a0799c230.png)
结果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/d6966d52547046aa8622778be808f99c.png)
结论：所有对象需要序列化，要不会报错！

实际开发中，不使用默认的RedisTemplate，要写自己的RedisTemplate。

```java
public class RedisConfig {

    // 这是我给大家写好的一个固定模板，大家在企业中，拿去就可以直接使用！    
    // 自己定义了一个 RedisTemplate     
    @Bean
    @SuppressWarnings("all")
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {

        // 我们为了自己开发方便，一般直接使用 <String, Object>
        RedisTemplate<String, Object> template = new RedisTemplate<String, Object>();
        template.setConnectionFactory(factory);

        // Json序列化配置
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);

        // String 的序列化
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();

        // key采用String的序列化方式        
        template.setKeySerializer(stringRedisSerializer);

        // hash的key也采用String的序列化方式
        template.setHashKeySerializer(stringRedisSerializer);

        // value序列化方式采用jackson        
        template.setValueSerializer(jackson2JsonRedisSerializer);

        // hash的value序列化方式采用jackson        
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        return template;
    }
}
```

这样测试类，再测试，就可以使用自己的RedisTemplate工具类了。

实际开发中，要封装自己的redis工具类：redisUtil

redisUtil中注入自己的RedisTemplate。

测试：注入redisUtil，调用redisUtil的方法。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d88c3b15e0444790b1d6e36e21074606.png)
返回结果：haha123

## 5、Spring Data Redis
Spring-data-redis是spring大家族的一部分，提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis, JRedis, and RJC)进行了高度封装，RedisTemplate提供了redis各种操作、异常处理及序列化，支持发布订阅，并对spring 3.1 cache进行了实现。

spring-data-redis针对jedis提供了如下功能：

1、连接池自动管理，提供了一个高度封装的“RedisTemplate”类
2、针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口
- ValueOperations：简单K-V操作
- SetOperations：set类型数据操作
- ZSetOperations：zset类型数据操作
- HashOperations：针对map类型的数据操作
- ListOperations：针对list类型的数据操作
3、提供了对key的“bound”(绑定)便捷化操作API，可以通过bound封装指定的key，然后进行一系列的操作而无须“显式”的再次指定Key，即BoundKeyOperations：
- BoundValueOperations
- BoundSetOperations
- BoundListOperations
- BoundSetOperations
- BoundHashOperations
4、将事务操作封装，有容器控制。
5、针对数据的“序列化/反序列化”，提供了多种可选择策略(RedisSerializer)

<font color=red>JdkSerializationRedisSerializer：</font>POJO对象的存取场景，使用JDK本身序列化机制，将pojo类通过ObjectInputStream/ObjectOutputStream进行序列化操作，最终redis-server中将存储字节序列。是目前最常用的序列化策略。

<font color=red>StringRedisSerializer：</font>Key或者value为字符串的场景，根据指定的charset对数据的字节序列编码成string，是“new String(bytes, charset)”和“string.getBytes(charset)”的直接封装。是最轻量级和高效的策略。

<font color=red>JacksonJsonRedisSerializer：</font>jackson-json工具提供了javabean与json之间的转换能力，可以将pojo实例序列化成json格式存储在redis中，也可以将json格式的数据转换成pojo实例。因为jackson工具在序列化和反序列化时，需要明确指定Class类型，因此此策略封装起来稍微复杂。【需要jackson-mapper-asl工具支持】有的redis操作，其实对于java开发人员来说，十分的简单，更重要是要去理解redis的思想和每一种数据结构的用处和作用场景！

# 八、Redis.conf详解
启动的时候，就通过配置文件来启动！

**单位（units）**
![在这里插入图片描述](https://img-blog.csdnimg.cn/b4331d20bfc84affb2eb0130045c8327.png)
配置文件 unit单位 对大小写不敏感！

**包含（INCLUDES）**

![在这里插入图片描述](https://img-blog.csdnimg.cn/339bb024c40644a59c743c7749b94e99.png)
就是好比我们学习Spring时候的Improt， JSP中的include

**网络（NETWORK）**

```bash
bind 127.0.0.1    # 绑定的ip
ipprotected-mode yes # 保护模式：开启
port 6379  # 端口设置
```

**通用（GENERAL）**

```bash
daemonize yes   # 以守护进程的方式运行，默认是 no，我们需要自己开启为yes！
pidfile /var/run/redis_6379.pid  # 如果以后台的方式运行，我们就需要指定一个 pid 文件！

# 日志级别
# Specify the server verbosity level.
# This can be one of:
# debug (a lot of information, useful for development/testing)
# verbose (many rarely useful info, but not a mess like the debug level)
# notice (moderately verbose, what you want in production probably)
# warning (only very important / critical messages are logged)
loglevel notice

# 日志的文件位置名
# Specify the log file name. Also the empty string can be used to force
# Redis to log on the standard output. Note that if you use standard
# output for logging but daemonize, logs will be sent to /dev/null
logfile ""


databases 16  # 数据库的数量，默认是 16 个数据库
always-show-logo yes  # 是否总是显示LOGO
```

 **快照（SNAPSHOTTING）**

持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof

redis 是内存数据库，如果没有持久化，那么数据断电及失！

```bash
# 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作
save 900 1
# 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作
save 300 10
# 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作
save 60 10000
# 我们之后学习持久化，会自己定义这个测试！

stop-writes-on-bgsave-error yes   # 持久化如果出错，是否还需要继续工作！
rdbcompression yes # 是否压缩 rdb 文件，需要消耗一些cpu资源！
rdbchecksum yes # 保存rdb文件的时候，进行错误的检查校验！
dir ./  # rdb 文件保存的目录！
```

**主从复制（REPLICATION ）**

见后面内容：主从复制部分

**安全（SECURITY）**

可以在这里设置redis的密码，默认是没有密码！

直接在这个配置文件中设置：

```bash
requirepass 123456
```
一般的话，我们都是使用命令设置：

```bash
127.0.0.1:6379> ping
PONG
127.0.0.1:6379> config get requirepass   # 获取redis的密码
1) "requirepass"
2) ""
127.0.0.1:6379> config set requirepass "123456"   # 设置redis的密码OK
127.0.0.1:6379> config get requirepass # 发现所有的命令都没有权限了
(error) NOAUTH Authentication required.
127.0.0.1:6379> ping
(error) NOAUTH Authentication required.
127.0.0.1:6379> auth 123456  # 使用密码进行登录！
OK
127.0.0.1:6379> config get requirepass
1) "requirepass"
2) "123456"
```

**限制（CLIENTS）**

```bash
maxclients 10000   # 设置能连接上redis的最大客户端的数量
maxmemory <bytes>  # redis 配置最大的内存容量
maxmemory-policy noeviction  # 内存到达上限之后的处理策略    
	1、volatile-lru：只对设置了过期时间的key进行LRU（默认值）     
	2、allkeys-lru ： 删除lru算法的key       
	3、volatile-random：随机删除即将过期key       
	4、allkeys-random：随机删除       
	5、volatile-ttl ： 删除即将过期的       
	6、noeviction ： 永不过期，返回错误
```


**AOF配置（APPEND ONLY MODE）**

```bash
appendonly no    # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！
appendfilename "appendonly.aof"  # 持久化的文件的名字
# appendfsync always   # 每次修改都会 sync。消耗性能
appendfsync everysec   # 每秒执行一次 sync，可能会丢失这1s的数据！
# appendfsync no       # 不执行 sync，这个时候操作系统自己同步数据，速度最快！
```


# 九、Redis持久化

Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！


## 1、RDB（Redis DataBase）

**什么是RDB**

![在这里插入图片描述](https://img-blog.csdnimg.cn/0ce5193a48dd4f44a1ec8d2887aece2b.png)
- 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的 Snapshot快照，它恢复时是将快照文件直接读到内存里。
- Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！
- 有时候在生产环境我们会将这个文件进行备份！
- rdb保存的文件是dump.rdb 都是在我们的配置文件中快照中进行配置的！

![在这里插入图片描述](https://img-blog.csdnimg.cn/e690110a22564fe785ef2d073200a494.png)
自己设定，触发rdb操作
![在这里插入图片描述](https://img-blog.csdnimg.cn/e4bfcbc3eb0544de8eaa1cb690405b1a.png)

**触发机制**

1、save的规则满足的情况下，会自动触发rdb规则
2、执行 flushall 命令，也会触发我们的rdb规则！
3、退出redis，也会产生 rdb 文件！
备份就自动生成一个 dump.rdb

![在这里插入图片描述](https://img-blog.csdnimg.cn/5866bfef077e46f0aaddf96c07a75031.png)

**恢复rdb文件**

1、只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！

2、查看需要存在的位置

```bash
127.0.0.1:6379> config get dir
1) "dir"
2) "/usr/local/bin"  # 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据
```
几乎就他自己默认的配置就够用了，但是我们还是需要去学习！

**优点：**

1、适合大规模的数据恢复！ 
2、对数据的完整性要不高！

**缺点：**

1、需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有的了！
2、fork进程的时候，会占用一定的内容空间！！


## 2、AOF（Append Only File）

将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍！

**AOF是什么**

![**加粗样式**](https://img-blog.csdnimg.cn/95bdd88844d24410b50a579fae8fe248.png)

以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

AOF保存的是 appendonly.aof 文件。


**appendonly**

默认是不开启的，我们需要手动进行配置！我们只需要将 appendonly 改为yes就开启了 aof！
![在这里插入图片描述](https://img-blog.csdnimg.cn/ca9024e356514cc486bec236350ad24d.png)
重启，redis 就可以生效了！
![在这里插入图片描述](https://img-blog.csdnimg.cn/b428ca193de343068ae62524da5ff50b.png)


如果这个 aof 文件有错位，这时候 redis 是启动不起来的吗，我们需要修复这个aof文件
![在这里插入图片描述](https://img-blog.csdnimg.cn/f3f10e58386c4c8397a53e8fd5a29817.png)


redis 给我们提供了一个工具 `redis-check-aof --fix`
![在这里插入图片描述](https://img-blog.csdnimg.cn/825026c3c4184a1886be3d88929f0942.png)


如果文件正常，重启就可以直接恢复了！
![在这里插入图片描述](https://img-blog.csdnimg.cn/f3f55f35ae8f438ea5c2e1bcdf16695b.png)


**重写规则说明**

aof 默认就是文件的无限追加，文件会越来越大！
![在这里插入图片描述](https://img-blog.csdnimg.cn/d598c7300a164c4c965d314ead8cf735.png)


如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！

```bash
appendonly no    # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！
appendfilename "appendonly.aof"  # 持久化的文件的名字
# appendfsync always   # 每次修改都会 sync。消耗性能
appendfsync everysec   # 每秒执行一次 sync，可能会丢失这1s的数据！
# appendfsync no       # 不执行 sync，这个时候操作系统自己同步数据，速度最快！
# rewrite 重写
```

**优点：**

1、每一次修改都同步，文件的完整会更加好！
2、每秒同步一次，可能会丢失一秒的数据
3、从不同步，效率最高的！

**缺点：**

1、相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！
2、Aof 运行效率也要比 rdb 慢，所以我们redis默认的配置就是rdb持久化！


**扩展：**

1、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储 

2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。

3、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化

4、同时开启两种持久化方式

- 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
- RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。

5、性能建议

- 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。
- 如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite 的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。
- 如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。


# 十、Redis发布订阅
## 1、介绍及组成结构

Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。微信、微博、关注系统！

Redis 客户端可以订阅任意数量的频道。

订阅/发布消息图：
第一个：消息发送者， 第二个：频道 第三个：消息订阅者！

![在这里插入图片描述](https://img-blog.csdnimg.cn/33877aa09aab44ce941cb45eb2bd90b4.png)
下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：

![在这里插入图片描述](https://img-blog.csdnimg.cn/e3a3024bd96049e397e083c2cc1d3c76.png)
当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：

![在这里插入图片描述](https://img-blog.csdnimg.cn/8d7ec1bf30ef48e89169adacec600daf.png)

## 2、命令

这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。


![在这里插入图片描述](https://img-blog.csdnimg.cn/32305dc3235f43918e9aee4c59fff4e5.png)

## 3、测试
订阅端：

```bash
127.0.0.1:6379> SUBSCRIBE xiaorshuo  # 订阅一个频道
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "xiaorshuo"
3) (integer) 1
# 监听读取信息，等待读取推送的信息
1) "message"   # 消息
2) "xiaorshuo"   # 那个频道的消息
3) "hello xiaoR"   # 消息的具体内容
1) "message"
2) "xiaorshuo"
3) "hello redis"
```

发送端：

```bash
127.0.0.1:6379> PUBLISH xiaorshuo "hello xiaoR"  # 发布者发布消息到频道！
(integer) 1
127.0.0.1:6379> PUBLISH xiaorshuo "hello redis"
(integer) 1
```

## 4、原理
Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。

Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。

微信：通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 频道！，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4f2fe3f769f24c25a7abef1a699b4588.png)
通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。

![在这里插入图片描述](https://img-blog.csdnimg.cn/198c51b360cc4d78a9e3ab98d5008530.png)
Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。

**使用场景：**

1、实时消息系统！
2、事实聊天！（频道当做聊天室，将信息回显给所有人即可！）
3、订阅，关注系统都是可以的！
稍微复杂的场景我们就会使用 消息中间件 MQ （）

# 十一、Redis主从复制
## 1、概念
主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)。

<font color=red>数据的复制是单向的，只能由主节点到从节点。

Master以写为主，Slave 以读为主。

<font color=red>默认情况下，每台Redis服务器都是主节点。

且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。

**主从复制的作用主要包括：**

1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
4、高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：

1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；

2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。

电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是"多读少写"。对于这种场景，我们可以使如下这种架构：![在这里插入图片描述](https://img-blog.csdnimg.cn/ccf6934478624beda881cd05287e1475.png)
主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！

只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！

## 2、环境配置
只配置从库，不用配置主库！

```bash
127.0.0.1:6379> info replication   # 查看当前库的信息
# Replication
role:master   # 角色 master  代表主机
connected_slaves:0   # 0代表没有从机
master_failover_state:no-failover
master_replid:2589b3e910d357cc5d11fe16cc7f7e86a07eb651
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
```

复制3个配置文件，然后修改对应的信息：

![在这里插入图片描述](https://img-blog.csdnimg.cn/f1efaf68040c4c4f91b9448da4bfce07.png)
1、修改端口
![在这里插入图片描述](https://img-blog.csdnimg.cn/a90980205d35400eab3fd1ee20b6ae7f.png)
2、修改pid名称（指定以后台的方式运行）
![在这里插入图片描述](https://img-blog.csdnimg.cn/135e889e9e6541d19a92293cc091c232.png)
3、修改log文件名字
![在这里插入图片描述](https://img-blog.csdnimg.cn/ff816205356f4455b30e6ba5774fe48b.png)

4、修改dump.rdb 名字
![在这里插入图片描述](https://img-blog.csdnimg.cn/d6f47cd916d7443585e4e54111fa9401.png)

修改完毕之后，启动我们的3个redis服务器，可以通过进程信息查看！

```bash
[root@hecs-362578 rconfig]# redis-server redis79.conf  # 启动79的服务器
[root@hecs-362578 rconfig]# redis-server redis80.conf  # 启动80的服务器 
[root@hecs-362578 rconfig]# redis-server redis81.conf   # 启动81的服务器
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/5dbedfc4d58a42d2b063be57421fc23d.png)

## 3、一主二从
### 3.1 介绍
现在查看每一个都是主机：
![在这里插入图片描述](https://img-blog.csdnimg.cn/72e2b8b2af0f4622b5515d560e6793ae.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/38b1c33b8fcb43d28fe911a76aed2c19.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/5aed68080a62416b8a7c630c93e445b1.png)


默认情况下，每台Redis服务器都是主节点。
我们一般情况下只用配置从机就好了！
规则就是认老大！ 一主 （79）二从（80，81）

### 3.2 配置

**配置从机80：**

```bash
127.0.0.1:6380> SLAVEOF 127.0.0.1 6379  # SLAVEOF host 6379   找谁当自己的老大！
OK
127.0.0.1:6380> info replication
# Replication
role:slave # 当前角色是从机
master_host:127.0.0.1  # 可以的看到主机的信息：IP
master_port:6379  # 可以的看到主机的信息：端口
master_link_status:up
master_last_io_seconds_ago:7
master_sync_in_progress:0
slave_repl_offset:14
slave_priority:100
slave_read_only:1
connected_slaves:0
master_failover_state:no-failover
master_replid:f392f0f91c5a1edaa668f64287637b3d98ff7b09
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:14
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:14
```

**配置从机81：**

```bash
127.0.0.1:6381> SLAVEOF 127.0.0.1 6379
OK
127.0.0.1:6381> info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
master_link_status:up
master_last_io_seconds_ago:4
master_sync_in_progress:0
slave_repl_offset:252
slave_priority:100
slave_read_only:1
connected_slaves:0
master_failover_state:no-failover
master_replid:f392f0f91c5a1edaa668f64287637b3d98ff7b09
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:252
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:239
repl_backlog_histlen:14
```

**在主机79中查看：**

```bash
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:2  # 有两个从机（80、81）的配置
slave0:ip=127.0.0.1,port=6380,state=online,offset=322,lag=1  # 多了从机80的配置
slave1:ip=127.0.0.1,port=6381,state=online,offset=322,lag=1  # 多了从机81的配置
master_failover_state:no-failover
master_replid:f392f0f91c5a1edaa668f64287637b3d98ff7b09
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:322
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:322
```

真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的！

主机可以写，从机不能写，只能读！主机中的所有信息和数据，都会自动被从机保存！

主机写：
```bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> get k1
"v1"
```

从机读：

```bash
127.0.0.1:6380> keys *
1) "k1"
127.0.0.1:6380> get k1
"v1"
127.0.0.1:6380> set k2 v2  # 从机执行写操作的话，会报错！
(error) READONLY You can't write against a read only replica.
```

### 3.3 测试
**测试一：主机宕机（断开）**

主机79断开：
![在这里插入图片描述](https://img-blog.csdnimg.cn/81c4ceee33fc4550ac2a57eeaaa2535d.png)
可以看到主机79进程没了
![在这里插入图片描述](https://img-blog.csdnimg.cn/3a6b15010f684d3884f3423ef203b327.png)
查看从机80，发现他的主机还是原来的主机79！

```bash
127.0.0.1:6380> info replication
# Replication
role:slave   # 角色还是从机
master_host:127.0.0.1    # 主机没变
master_port:6379
master_link_status:down
master_last_io_seconds_ago:-1
master_sync_in_progress:0
slave_repl_offset:2044
master_link_down_since_seconds:179
slave_priority:100
slave_read_only:1
connected_slaves:0
master_failover_state:no-failover
master_replid:f392f0f91c5a1edaa668f64287637b3d98ff7b09
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:2044
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:2044
```

现在从机80只有一个k1

```bash
127.0.0.1:6380> keys *
1) "k1"
```

现在主机79又连接上了：

```bash
[root@hecs-362578 rconfig]# redis-server redis79.conf 
[root@hecs-362578 rconfig]# redis-cli -p 6379
127.0.0.1:6379> keys *
1) "k1"
127.0.0.1:6379> ping
PONG
```

主机79设定值k2：

```bash
127.0.0.1:6379> set k2 v2
OK
127.0.0.1:6379> keys *
1) "k1"
2) "k2"
```

从机80依旧可以获取到

```bash
127.0.0.1:6380> keys *
1) "k1"
2) "k2"
127.0.0.1:6380> get k2
"v2"
```

测试总结：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！


**测试二：从机宕机（断开）**

从机80断开：

```bash
127.0.0.1:6380> SHUTDOWN
not connected> exit
```

从机80没有了
![在这里插入图片描述](https://img-blog.csdnimg.cn/4316a6ba777a4372948e0d6c1a5f510a.png)
查看主机79中的从机，只有一个了
![在这里插入图片描述](https://img-blog.csdnimg.cn/7bbd9b1f42614f3aba8108634aa19e9a.png)
现在给主机79设置一个值k3

```bash
127.0.0.1:6379> set k3 v3
OK
127.0.0.1:6379> keys *
1) "k3"
2) "k1"
3) "k2"
```

再次连接断开的从机80

```bash
[root@hecs-362578 rconfig]# redis-server redis80.conf 
[root@hecs-362578 rconfig]# redis-cli -p 6380
```
从机中查看k3和keys*

```bash
127.0.0.1:6380> get k3
(nil)
127.0.0.1:6380> keys *
1) "k1"
2) "k2"
```

发现从机80又变成了主机
![在这里插入图片描述](https://img-blog.csdnimg.cn/338905cce64443ea8e2997fd11a8c042.png)

再次把从机80变成主机79的从机：

```bash
127.0.0.1:6380> SLAVEOF 127.0.0.1 6379
OK
127.0.0.1:6380> INFO replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
master_link_status:up
master_last_io_seconds_ago:2
master_sync_in_progress:0
slave_repl_offset:444
slave_priority:100
slave_read_only:1
connected_slaves:0
master_failover_state:no-failover
master_replid:3799bb3db1acf40285c5c2f18fa7efa7709c14cb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:444
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:417
repl_backlog_histlen:28
```
查看主机79有两个从机：

```bash
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6381,state=online,offset=682,lag=0
slave1:ip=127.0.0.1,port=6380,state=online,offset=682,lag=0
master_failover_state:no-failover
master_replid:3799bb3db1acf40285c5c2f18fa7efa7709c14cb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:682
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:682
```


再次在从机80查看key，有了

```bash
127.0.0.1:6380> get k3
"v3"
127.0.0.1:6380> keys *
1) "k2"
2) "k1"
3) "k3"
```

测试总结：如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从主机中获取值！

### 3.4 复制原理
Slave 启动成功连接到 master 后会发送一个sync同步命令

Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。

全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。
增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步

但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！

### 3.5 层层链路模式
上一个主节点链接下一个 从节点！

就是6380认6379为老大，6381认6380为老大。

所以6380就会变成既是主节点，又是从节点。

master---slaver master---slaver

![在这里插入图片描述](https://img-blog.csdnimg.cn/745684526f9d41b5835c16b830f2e8a7.png)
设置从机81的主机是从机80：

```bash
127.0.0.1:6381> SLAVEOF 127.0.0.1 6380
OK
127.0.0.1:6381> info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6380
master_link_status:up
master_last_io_seconds_ago:0
master_sync_in_progress:0
slave_repl_offset:9124
slave_priority:100
slave_read_only:1
connected_slaves:0
master_failover_state:no-failover
master_replid:3799bb3db1acf40285c5c2f18fa7efa7709c14cb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:9124
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:9124
```

查看主机79的从机只有一个：

```bash
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:1
slave0:ip=127.0.0.1,port=6380,state=online,offset=9530,lag=0
master_failover_state:no-failover
master_replid:3799bb3db1acf40285c5c2f18fa7efa7709c14cb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:9530
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:9530
```

查看从机80，还是从机，没有变成主机：

```bash
127.0.0.1:6380> info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
slave_repl_offset:9502
slave_priority:100
slave_read_only:1
connected_slaves:1
slave0:ip=127.0.0.1,port=6381,state=online,offset=9502,lag=0
master_failover_state:no-failover
master_replid:3799bb3db1acf40285c5c2f18fa7efa7709c14cb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:9502
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:417
repl_backlog_histlen:9086
```

给主机79设置一个值k4：

```bash
127.0.0.1:6379> set k4 v4
OK
127.0.0.1:6379> keys *
1) "k3"
2) "k4"
3) "k1"
4) "k2"
```

从机80中可以取得值：

```bash
127.0.0.1:6380> get k4
"v4"
127.0.0.1:6380> keys *
1) "k4"
2) "k2"
3) "k1"
4) "k3"
```

从机81中可以取得值：

```bash
127.0.0.1:6381> get k4
"v4"
127.0.0.1:6381> keys *
1) "k4"
2) "k3"
3) "k2"
4) "k1"
```

这时候也可以完成我们的主从复制！


如果没有主机（主机宕机了），从机想自己变成主机使用命令`SLAVEOF no one`

```bash
127.0.0.1:6381> SLAVEOF no one
OK
127.0.0.1:6381> info replication
# Replication
role:master
connected_slaves:0
master_failover_state:no-failover
master_replid:011b3d0664d4f204b8e7050488c5d6f253609150
master_replid2:3799bb3db1acf40285c5c2f18fa7efa7709c14cb
master_repl_offset:10408
second_repl_offset:10409
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:10408
```

这样其他节点就可以手动连接到这个最新的主节点了（手动）！

现在还是链路模式，主机79-从机80-从机81，81的主机是79。现在断开79，断开80，从新连接80，发现80成为了主机，从机有一个是81。

## 4、哨兵模式

（自动选举老大的模式）

### 4.1 概念
主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。

谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数<font color=red>自动将从库转换为主库。

哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。<font color=red>其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。

![在这里插入图片描述](https://img-blog.csdnimg.cn/7e4345e0f49d425bb29609975f40d1f7.png)

这里的哨兵有两个作用:
- 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。
- 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。

然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。

![在这里插入图片描述](https://img-blog.csdnimg.cn/732953a5345c4550919e8b50cd14ba2f.png)

假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为**主观下线**。

当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**客观下线**。


### 4.2 测试
我们目前的状态是 一主二从！

1、配置哨兵配置文件 sentinel.conf

```bash
[root@hecs-362578 rconfig]# vim sentinel.conf
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/c94f443bdf514525942a0b965eff4aaa.png)

```bash
# sentinel monitor 被监控的名称 host port 1
sentinel monitor myredis 127.0.0.1 6379 1
```

后面的这个数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机！

2、启动哨兵

```bash
[root@hecs-362578 rconfig]# redis-sentinel sentinel.conf 
434503:X 07 Dec 2021 14:46:23.877 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
434503:X 07 Dec 2021 14:46:23.877 # Redis version=6.2.1, bits=64, commit=00000000, modified=0, pid=434503, just started
434503:X 07 Dec 2021 14:46:23.877 # Configuration loaded
434503:X 07 Dec 2021 14:46:23.878 * monotonic clock: POSIX clock_gettime
                _._                                                  
           _.-``__ ''-._                                             
      _.-``    `.  `_.  ''-._           Redis 6.2.1 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._                                   
 (    '      ,       .-`  | `,    )     Running in sentinel mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 26379
 |    `-._   `._    /     _.-'    |     PID: 434503
  `-._    `-._  `-./  _.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |           http://redis.io        
  `-._    `-._`-.__.-'_.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |                                  
  `-._    `-._`-.__.-'_.-'    _.-'                                   
      `-._    `-.__.-'    _.-'                                       
          `-._        _.-'                                           
              `-.__.-'                                               

434503:X 07 Dec 2021 14:46:23.879 # Sentinel ID is 645eb5ca9edcacfee342122023fe146a0d5e09e3
434503:X 07 Dec 2021 14:46:23.879 # +monitor master myredis 127.0.0.1 6379 quorum 1
434503:X 07 Dec 2021 14:46:23.880 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379
434503:X 07 Dec 2021 14:46:23.887 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379
```

如果Master 节点断开了，这个时候就会从从机中随机选择一个服务器！ （这里面有一个投票算法！） 

从机80成为了主机：

```bash
127.0.0.1:6380> info replication
# Replication
role:master
connected_slaves:1
slave0:ip=127.0.0.1,port=6381,state=online,offset=38056,lag=0
master_failover_state:no-failover
master_replid:f6744ce084b611416de13cc072176c77ed38f0f0
master_replid2:1c03f43e69a01066e930f5f6f6593d66e4c6d942
master_repl_offset:38070
second_repl_offset:13770
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:15
repl_backlog_histlen:38056
```
从机81的主机变成了80：

```bash
127.0.0.1:6381> info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6380
master_link_status:up
master_last_io_seconds_ago:2
master_sync_in_progress:0
slave_repl_offset:37250
slave_priority:100
slave_read_only:1
connected_slaves:0
master_failover_state:no-failover
master_replid:f6744ce084b611416de13cc072176c77ed38f0f0
master_replid2:1c03f43e69a01066e930f5f6f6593d66e4c6d942
master_repl_offset:37250
second_repl_offset:13770
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:37250
```

哨兵日志：

```bash
434522:X 07 Dec 2021 14:51:07.743 # +selected-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379
434522:X 07 Dec 2021 14:51:07.743 * +failover-state-send-slaveof-noone slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379
434522:X 07 Dec 2021 14:51:07.805 * +failover-state-wait-promotion slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379
434522:X 07 Dec 2021 14:51:07.988 # +promoted-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379
434522:X 07 Dec 2021 14:51:07.988 # +failover-state-reconf-slaves master myredis 127.0.0.1 6379
434522:X 07 Dec 2021 14:51:08.082 * +slave-reconf-sent slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379
434522:X 07 Dec 2021 14:51:09.011 * +slave-reconf-inprog slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379
434522:X 07 Dec 2021 14:51:09.011 * +slave-reconf-done slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379
434522:X 07 Dec 2021 14:51:09.094 # +failover-end master myredis 127.0.0.1 6379
434522:X 07 Dec 2021 14:51:09.094 # +switch-master myredis 127.0.0.1 6379 127.0.0.1 6380
434522:X 07 Dec 2021 14:51:09.094 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6380
434522:X 07 Dec 2021 14:51:09.094 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6380
434522:X 07 Dec 2021 14:51:39.101 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6380
```
通过日志的最后一句也可以看出主机是80。

如果主机79此时回来了，只能归并到新的主机80下，被当做从机，这就是哨兵模式的规则！

```bash
[root@hecs-362578 rconfig]# redis-server redis79.conf 
[root@hecs-362578 rconfig]# redis-cli -p 6379
127.0.0.1:6379> info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6380
master_link_status:up
master_last_io_seconds_ago:2
master_sync_in_progress:0
slave_repl_offset:76921
slave_priority:100
slave_read_only:1
connected_slaves:0
master_failover_state:no-failover
master_replid:f6744ce084b611416de13cc072176c77ed38f0f0
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:76921
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:75141
repl_backlog_histlen:1781
```

### 4.3 优缺点

优点：
1、哨兵集群，基于主从复制模式，所有的主从配置优点，它全有
2、 主从可以切换，故障可以转移，系统的可用性就会更好
3、哨兵模式就是主从模式的升级，手动到自动，更加健壮！

缺点：
1、Redis 不好在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！
2、实现哨兵模式的配置其实是很麻烦的，里面有很多选择！

### 4.4 哨兵模式的全部配置
完整的哨兵模式配置文件 sentinel.conf
```bash
# Example sentinel.conf
 
# 哨兵sentinel实例运行的端口 默认26379
port 26379
 
# 哨兵sentinel的工作目录
dir /tmp
 
# 哨兵sentinel监控的redis主节点的 ip port 
# master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。
# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了
# sentinel monitor <master-name> <ip> <redis-port> <quorum>
sentinel monitor mymaster 127.0.0.1 6379 1
 
# 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码
# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码
# sentinel auth-pass <master-name> <password>
sentinel auth-pass mymaster MySUPER--secret-0123passw0rd
 
 
# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒
# sentinel down-after-milliseconds <master-name> <milliseconds>
sentinel down-after-milliseconds mymaster 30000
 
# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，
# 这个数字越小，完成failover所需的时间就越长，
# 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。
# 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。
# sentinel parallel-syncs <master-name> <numslaves>
sentinel parallel-syncs mymaster 1
 
 
 
# 故障转移的超时时间 failover-timeout 可以用在以下这些方面： 
#1. 同一个sentinel对同一个master两次failover之间的间隔时间。
#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。
#3.当想要取消一个正在进行的failover所需要的时间。  
#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了
# 默认三分钟
# sentinel failover-timeout <master-name> <milliseconds>
sentinel failover-timeout mymaster 180000
 
# SCRIPTS EXECUTION
 
#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。
#对于脚本的运行结果有以下规则：
#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10
#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。
#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。
#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。
 
#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，
#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，
#一个是事件的类型，
#一个是事件的描述。
#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。
#通知脚本
# sentinel notification-script <master-name> <script-path>
  sentinel notification-script mymaster /var/redis/notify.sh
 
# 客户端重新配置主节点参数脚本
# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。
# 以下参数将会在调用脚本时传给脚本:
# <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>
# 目前<state>总是“failover”,
# <role>是“leader”或者“observer”中的一个。 
# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的
# 这个脚本应该是通用的，能被多次调用，不是针对性的。
# sentinel client-reconfig-script <master-name> <script-path>
sentinel client-reconfig-script mymaster /var/redis/reconfig.sh
```

# 十二、Redis缓存穿透、击穿和雪崩

服务的高可用问题！

在这里我们不会详细的区分析解决方案的底层！

Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。

另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。

## 1、缓存穿透（查不到）
### 1.1 概念
缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。
![在这里插入图片描述](https://img-blog.csdnimg.cn/811bd67db1614664bd179d4897bfaaf8.png)
### 1.2 解决方案
**布隆过滤器**

布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；

![在这里插入图片描述](https://img-blog.csdnimg.cn/53e587c55f114d98a0f509f634ad81eb.png)

**缓存空对象**

当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；

![在这里插入图片描述](https://img-blog.csdnimg.cn/106b875535024c95a5a96a8c38cef9a4.png)
但是这种方法会存在两个问题：
1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；
2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。

## 2、缓存击穿（量太大，缓存过期！）
### 2.1 概念
这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。
![在这里插入图片描述](https://img-blog.csdnimg.cn/5acf1169fabb49b9a25d3d12d626cc9e.png)


### 2.2 解决方案
**设置热点数据永不过期**

从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。

**加互斥锁**

分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。

## 3、缓存雪崩
### 3.1 概念
缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！

产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。
![在这里插入图片描述](https://img-blog.csdnimg.cn/883a7e4c3c7d4ad5acea2b3a015e2f2c.png)
其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。

### 3.2 解决方案
**redis高可用**

这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）

**限流降级**

这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

**数据预热**

数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 



# 十三、附录



> 视频笔记来自《狂神说Java》
> B站地址：[Redis最新超详细版教程通俗易懂](https://www.bilibili.com/video/BV1S54y1R7SB)



gitee地址：https://gitee.com/gitofrr/kuangshen-redis-study

